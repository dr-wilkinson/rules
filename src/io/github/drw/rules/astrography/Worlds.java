package io.github.drw.rules.astrography;

import io.github.drw.rules.worlds.World;
import java.util.HashMap;
import java.util.Map;

/**
 * A collection of all the {@link BirthWorld}s within playable space.
 *
 * @author dr-wilkinson
 */
class Worlds {

    private final Map<Address, World> worlds = new HashMap<>();
    private String message;

    /**
     * Attempts to add the {@link BirthWorld} at the {@link Address} provided.
     * If the BirthWorld can't be added at the Address, an error message is
     * generated that can be retrieved using {@code getMessage()}.
     *
     * @param address The Address to add the BirthWorld at.
     * @param world The BirthWorld to add at the Address.
     * @return true if the BirthWorld was added at the Address, otherwise false.
     */
    boolean addWorld(Address address, World world) {
        if (contains(address)) {
            for (Map.Entry<Address, World> entry : worlds.entrySet()) {
                if (entry.getKey().equals(address)) {
                    if (entry.getValue().getName().equals(world.getName())) {
                        message = "Error: There is already a World called " + world.getName() + "at that address!";
                        return false;
                    }
                }
            }
        }
        worlds.put(address, world);
        return true;
    }

    /**
     * Does this collection of {@link BirthWorld}s contain the supplied
     * {@link Address}? If the Address can't be found, an error message is
     * generated that can be retrieved using {@code getMessage()}.
     *
     * @param address The Address to check.
     * @return true if the Address is present, otherwise false.
     */
    boolean contains(Address address) {
        if (worlds.containsKey(address)) {
            return true;
        } else {
            message = "Error: Couldn't find a World at Address: " + address.asText();
            return false;
        }
    }

    /**
     * Attempts to retrieve the {@link World} identified by name and an
     * {@link Address}. If the World cannot be retrieved, an error message is
     * generated that can be retrieved using {@code getMessage()}.
     *
     * @param address The Address to search with.
     * @param name The name to search for.
     * @return The World identified by name and address or null.
     */
    World getWorld(Address address, String name) {
        for (Map.Entry<Address, World> entry : worlds.entrySet()) {
            Address key = entry.getKey();
            World value = entry.getValue();
            if (key.equals(address) && value.equals(name)) {
                return value;
            }
        }
        message = "Error: Could not locate World " + name + " at Address " + address.asText();
        return null;
    }

    /**
     * Returns the error message generated by failure to add, find and get
     * {@link World}s.
     *
     * @return The error message.
     */
    String getMessage() {
        return message;
    }

}
